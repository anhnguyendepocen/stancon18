---
title: "A Tutorial on Hidden Markov Models using Stan"
author: "Luis Damiano"
date: "2017-09-15"
output:
  rmarkdown::pdf_document:
    toc: true
    number_sections: true
    includes:
      in_header: Rmd/preamble-pdf.Rmd
bibliography: references.bib
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = FALSE, fig.width = 9.8)
library(rstan)
source('R/plots.R')
```

This case study documents the implementation in [Stan](http://mc-stan.org/) [@carpenter2016stan] of the Hidden Markov Model (HMM) for unsupervised learning [@baum1966statistical; @baum1967inequality; @baum1968growth; @baum1970maximization; @baum1972inequality]. Additionally, we present the adaptations needed for the Input-Output Hidden Markov Model (IOHMM). IOHMM is an architecture proposed by @bengio1995input to map input sequences, sometimes called the control signal, to output sequences. Compared to HMM, it aims at being especially effective at learning long term memory, that is when input-output sequences span long points. In all cases, we provide a fully Bayesian estimation of the model parameters and inference on hidden quantities, namely filtered state belief, smoothed state belief and jointly most probable state path.

_A Tutorial on Hidden Markov Models using Stan_ is licensed under CC-BY 4.0. See the [LICENSE](LICENSE.md) file for details. All files are available in the [stancon18](https://github.com/luisdamiano/stancon18) GitHub repository.

---

# The Hidden Markov Model

Real-world processes produce observable outputs characterized as signals. These can be discrete or continuous in nature, be pure or contaminated with noise, come from a stationary or non stationary source, among many other variations. These signals are modeled to allow for both theoretical descriptions and practical applications. The model itself can be deterministic or stochastic, in which case the signal is well characterized as a parametric random process whose parameters can be estimated in a well-defined manner.

Autocorrelation, a key feature in most signals, can be modeled in countless forms. While certainly pertinent to this purpose, high order Markov chains can prove inconvenient when the range of the correlation among the observations is long. A more parsimonious approach assumes that the observed sequence is a noisy observation of an underlying hidden process represented as a first-order Markov chain. In other terms, long-range dependencies between observations are mediated via latent variables. It is important to note that the Markov property is only assumed for the hidden states and not for the observations themselves.

## Model specification
HMM involves two interconnected models. The state model consists of a discrete-time, discrete-state, first order hidden Markov chain $z_t \in \{1, \dots, K\}$ that transitions according to $p(z_t | z_{t-1})$. In turns, the observation model is governed by $p(\mat{x}_t | z_t)$, where $\mat{x}_t$ are the observations, emissions or output. The corresponding joint distribution is

\[
p(\mat{z}_{1:T}, \mat{x}_{1:T})
  = p(\mat{z}_{1:T}) p(\mat{x}_{1:T} | \mat{z}_{1:T})
  = \left[ p(z_1) \prod_{t=2}^{T}{p(z_t | z_{t-1})} \right] \left[ \prod_{t=1}^{T}{p(\mat{x}_t | z_{t})} \right].
\]

This is a specific instance of the state space model family in which the latent variables are discrete. Each single time slice corresponds to a mixture distribution with component densities given by $p(\mat{x}_t | z_t)$, thus HMM may be interpreted as an extension of a mixture model in which the choice of component for each observation is not selected independently but depends on the choice of component for the previous observation. In the case of a simple mixture model for an independent and identically distributed sample, the parameters of the transition matrix inside the $i$-th column are the same, so that the conditional distribution $p(z_t | z_{t-1})$ is independent of $z_{t-1}$.

When the output is discrete, the observation model commonly takes the form of an observation matrix

\[
p(\mat{x}_t = l | z_t = k, \mat{\theta}) = B(k, l).
\]

Alternatively, if the output is continuous, the observation model is frequently a conditional Gaussian
\[
p(\mat{x}_t | z_t = k, \mat{\theta}) = \mathcal{N}(\mat{x}_t | \mat{\mu}_k, \mat{\Sigma}_k).
\]

The latter is equivalent to a Gaussian mixture model with cluster membership ruled by Markovian dynamics, also known as Markov Switching Models (MSM). In this context, multiple sequential observations tend to share the same location until they suddenly jump into a new cluster.

The non-stochastic quantities of the model are the observed sequence $\mat{x}_t$, the length of the observed sequence $T$ and the number of hidden states $K$. The parameters of the models are $\mat{\theta} = (\mat{\pi}_1, \mat{\theta}_h, \mat{\theta}_o)$, where $\mat{\pi}_1$ is the initial state distribution, $\mat{\theta}_h$ are the parameters of the hidden model and $\mat{\theta}_o$ are the parameters of the state-conditional density function $p(\mat{x}_t | z_t)$. The form of $\mat{\theta}_h$ and $\mat{\theta}_o$ depends on the specification of each model. In the case under study, state transition is characterized by the $K \times K$ sized transition matrix $\mat{A} = \{a_{ij}\}$ with $a_{ij} = p(z_t = j | z_{t-1} = i)$.

The following Stan code illustrates the case of continuous observations where emissions are modeled as sampled from the Gaussian distribution with parameters $\mu_k$ and $\sigma_k$ for $k \in \{1, \dots, K\}$. Adaptation for categorical observations should follow the guidelines outlined in the manual [@team2017stan, section 10.6].

```{stan stan_params, echo = TRUE, eval = FALSE, output.var = "TRASH"}
data {
  int<lower=1> T;                   // number of observations (length)
  int<lower=1> K;                   // number of hidden states
  real x_t[T];                      // observations
}

parameters {
  // Discrete state model
  simplex[K] p_1k;                  // initial state probabilities
  simplex[K] A_ij[K];               // transition probabilities
                                    // A_ij[i][j] = p(z_t = j | z_{t-1} = i)

  // Continuous observation model
  ordered[K] mu_k;                  // observation means
  real<lower=0> sigma_k[K];         // observation standard deviations
}
```

## The generative model

We write a routine in the R programming language for our generative model. Broadly speaking, this involves three steps:

1. The generation of parameters according to the priors $\mat{\theta}^{(0)} \sim p(\mat{\theta})$.
2. The generation of the hidden path $\mat{z}_{1:T}^{(0)}$ according to the transition model parameters.
3. The generation of the observed quantities based on the sampling distribution $\mat{x}_t^{(0)} \sim p(\mat{x}_t | \mat{z}_{1:T}^{(0)}, \mat{\theta}^{(0)})$.

We break down the description of our code in these three steps.

```{r hmm_generate, echo = TRUE}
runif_simplex <- function(T) {
  x <- -log(runif(T))
  x / sum(x)
}

hmm_generate <- function(K, T) {
  # 1. Parameters
  p_1k <- runif_simplex(K)
  A_ij <- t(replicate(K, runif_simplex(K)))
  mu_k <- sort(rnorm(K, 10 * 1:K, 1))
  sigma_k <- abs(rnorm(K))

  # 2. Hidden path
  z_t <- vector("numeric", T)

  z_t[1] <- sample(1:K, size = 1, prob = p_1k)
  for (t in 2:T)
    z_t[t] <- sample(1:K, size = 1, prob = A_ij[z_t[t - 1], ])

  # 3. Observations
  x_t <- vector("numeric", T)
  for (t in 1:T)
    x_t[t] <- rnorm(1, mu_k[z_t[t]], sigma_k[z_t[t]])

  list(x_t = x_t, z_t = z_t,
       theta = list(p_1k = p_1k, A_ij = A_ij,
                    mu_k = mu_k, sigma_k = sigma_k))
}
```

### Generating parameters from the priors

The parameters to be generated include the $K$-sized initial state distribution vector $\mat{\pi}_1$ and the $K \times K$ transition matrix $\mat{A}$. There are $(K-1)(K+1)$ free parameters as the vector and each row of the matrix are simplexes.

We set up uniform priors for $\mat{\pi}_1$ and $\mat{A}$, a weakly informative Gaussian for the location parameter $\mu_k$ and a weakly informative half-Gaussian that ensures positivity for the scale parameters $\sigma_k$. An ordinal constraint is imposed on the location parameter to restrict the exploration of the symmetric, degenerate mixture posterior surface to a single ordering of the parameters, thus solving the non-identifiability issues inherent to the model density [@betancourt2017identifying]. In the simulation routine, the location parameters are adjusted to ensure that the observations are well-separated. We refer the reader to the [Prior Choice Recommendations](https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations) wiki article for very useful practical guidelines that are both computationally and statistically meaningful. Given the fixed quantity $K$, we draw one sample from the prior distributions $\mat{\theta}^{(0)} \sim p(\mat{\theta})$.

### Generating the hidden path

The initial hidden state is drawn from a multinomial distribution with one trial and event probabilities given by the initial state probability vector $\mat{\pi}_1^{(0)}$. Given the fixed quantity $T$, the transition probabilities for each of the following steps $t \in \{2, \dots, T\}$ are generated from a multinomial distribution with one trial and event probabilities given by the $i$-th row of the transition matrix $\mat{A}_1^{(0)}$ where $i$ is the state at the previous time step $z_{t-1}^{(0)} = i$. The hidden states are subsequently sampled based on these transition probabilities.

### Generating data from the sampling distribution

The observation is drawn from a univariate Gaussian density with parameters $\mu_k^{(0)}$ and $\sigma_k^{(0)}$.

<!-- Note that the observation model may take many other shapes, including the large family of models with one set of parameter per possible hidden state known by the umbrella term Markov Switching Models. -->

## Characteristics

One of the most powerful properties of HMM is the ability to exhibit some degree of invariance to local warping of the time axis. Allowing for compression or stretching of the time, the model accommodates for variations in speed. By specification of the latent model, the density function of the duration $\tau$ in state $i$ is given by

\[
p_i(\tau) = (A_{ii})^{\tau} (1 - A_{ii}) \propto \exp (-\tau \ln A_{ii}),
\]

which represents the probability that a sequence spends precisely $\tau$ steps in state $i$. The expected duration conditional on starting in that state is

\[
\bar{\tau}_i = \sum_{\tau = 1}^{\infty}{\tau p_i(\tau)} = \frac{1}{1 - A_{ii}}.
\]

The density is an exponentially decaying function of $\tau$, thus longer durations are more probable than shorter ones. In applications where this proves unrealistic, the diagonal coefficients of the transition matrix $A_{ii} \ \forall \ i$ may be set to zero and each state $i$ is explicitly associated with a probability distribution of possible duration times $p(\tau | i)$ [@rabiner1990tutorial].

## Inference

There are several quantities of interest that can be inferred via different algorithms. Our code contains the implementation of the most relevant methods for unsupervised data: forward, forward-backward and Viterbi encoding algorithms. We acknowledge the authors of the Stan Manual for the thorough illustrations and code snippets, some of which served as a starting point for our own code. As estimation is treated later, we assume that model parameters $\mat{\theta}$ are known.

\scriptsize

```{r inference_table, echo = FALSE, eval = TRUE}
df <- data.frame(
  name = c("Filtering", 
           "Smoothing", 
           "Fixed lag smoothing", 
           "State prediction", 
           "Observation prediction", 
           "MAP Estimation", 
           "Probability of the evidence"),
  hidden = c("$p(z_t | \\mat{x}_{1:t})$",
             "$p(z_t | \\mat{x}_{1:T})$",
             "$p(z_{t - \\ell} | \\mat{x}_{1:t})$, $\\ell \\ge 1$",
             "$p(z_{t+h} | \\mat{x}_{1:t})$, $h\\ge 1$",
             "$p(x_{t+h} | \\mat{x}_{1:t})$, $h\\ge 1$",
             "?",
             "$p(\\mat{x}_{1:T})$"),
  availability = c("$t$ (online)",
                   "$T$ (offline)",
                   "$t + \\ell$ (lagged)",
                   "$t$",
                   "$t$",
                   "$T$",
                   "$T$"),
  algorithm = c("Forward",
                "Forward-backward",
                "",
                "",
                "",
                "Viterbi encoding",
                "Forward"),
  complexity = c("$O(K^2T)$ \\ $O(KT)$ if left-to-right",
                 "$O(K^2T)$ \\ $O(KT)$ if left-to-right",
                 "",
                 "",
                 "",
                 "$O(K^2T)$ \\ $O(KT)$ if sparse",
                 "$O(K^2T)$ \\ $O(KT)$ if left-to-right")
)

df.col <- c("Name",
            "Hidden Quantity",
            "Availability at",
            "Algorithm",
            "Complexity")

knitr::kable(df, col.names = df.col, 
             caption = "Summary of the hidden quantities and their corresponding inference algorithm.",
             table.attr = "style = 'width:100%;'")
```

\normalsize

### Filtering
A filter infers the belief state at a given step $t$ based on all the information available up to that point $p(z_t | \mat{x}_{1:t})$. It achieves better noise reduction than simply estimating the hidden state based on the current estimate $p(z_t | \mat{x}_{t})$. The filtering process can be run online, or recursively, as new data streams in.

Filtered marginals can be computed recursively by means of the forward algorithm [@baum1967inequality]. Let $\psi_t(j) = p(\mat{x}_t | z_t = j)$ be the local evidence at step $t$ and $\Psi(i, j) = p(z_t = j | z_{t-1} = i)$ be the transition probability. First, the one-step-ahead predictive density is computed

\[
p(z_t = j | \mat{x}_{1:t-1}) = \sum_{i}{\Psi(i, j) p(z_{t-1} = i | \mat{x}_{1:t-1})}.
\]

Acting as prior information, this quantity is updated with observed data at the step $t$ using Bayes rule,

\begin{align*}
\label{eq:filtered-beliefstate}
\alpha_t(j) 
  & \triangleq  p(z_t = j | \mat{x}_{1:t}) \\
  &= p(z_t = j | \mat{x}_{t}, \mat{x}_{1:t-1}) \\
  &= Z_t^{-1} \psi_t(j) p(z_t = j | \mat{x}_{1:t-1}) \\
\end{align*}
  <!-- &= Z_t^{-1} \psi_t(j) \alpha_{t-1}(j), -->
  <!-- &= \psi_t(j) \sum_{l}{\Psi(i, l) \alpha_{t-1}(l)} -->
  
where the normalization constant is given by

\[
Z_t
  \triangleq  p(\mat{x}_t | \mat{x}_{1:t-1})
  = \sum_{l=1}^{K}{p(\mat{x}_{t} | z_t = l) p(z_t = l | \mat{x}_{1:t-1})}
  = \sum_{l=1}^{K}{\psi_t(l) p(z_t = l | \mat{x}_{1:t-1})}.
\]

This predict-update cycle results in the filtered belief states at step $t$. As this algorithm only requires the evaluation of the quantities $\psi_t(j)$ for each value of $z_t$ for every $t$ and fixed $\mat{x}_t$, the posterior distribution of the latent states is independent of the form of the observation density or indeed of whether the observed variables are continuous or discrete [@jordan2003introduction].

Let $\mat{\alpha}_t$ be a $K$-sized vector with the filtered belief states at step $t$, $\mat{\psi}_t(j)$ be the $K$-sized vector of local evidence at step $t$, $\mat{\Psi}$ be the transition matrix and $\mat{u} \odot \mat{v}$ be the Hadamard product, representing element-wise vector multiplication. Then, the Bayesian updating procedure can be expressed in matrix notation as

\[
\mat{\alpha}_t \propto \mat{\psi}_t \odot (\mat{\Psi}^T \mat{\alpha}_{t-1}).
\]

In addition to computing the hidden states, the algorithm yields the log probability of the evidence

\[
\log p(\mat{x}_{1:T} | \mat{\theta}) = \sum_{t=1}^{T}{\log p(\mat{x}_{t} | \mat{x}_{1:t-1})} = \sum_{t=1}^{T}{\log Z_t}.
\]

```{stan stan_forward, echo = TRUE, eval = FALSE, output.var = "TRASH"}
transformed parameters {
  vector[K] unalpha_tk[T];

  { // Forward algorithm log p(z_t = j | x_{1:t})
    real accumulator[K];

    unalpha_tk[1] = log(p_1k) + normal_lpdf(x_t[1] | mu_k, sigma_k);

    for (t in 2:T) {
      for (j in 1:K) { // j = current (t)
        for (i in 1:K) { // i = previous (t-1)
                         // Murphy (2012) p. 609 eq. 17.48
                         // belief state      + transition prob + local evidence at t
          accumulator[i] = unalpha_tk[t-1, i] 
                           + log(A_ij[i, j]) 
                           + normal_lpdf(x_t[t] | mu_k[j], sigma_k[j]);
        }
        unalpha_tk[t, j] = log_sum_exp(accumulator);
      }
    }
  } // Forward
}
```

The Stan code makes evident that the time complexity of the algorithm is $O(K^2T)$: there are $K \times K$ iterations within each of the $T$ iterations of the outer loop. Brute-forcing through all possible hidden states $K^T$ would prove prohibitive for realistic problems as time complexity increases exponentially with sequence length $O(K^TT)$.

The implementation is representative of the matrix notation in @murphy2012machine [eq. 17.48]. The `accumulator` variable carries the element-wise operations for all possible previous states which are later combined as indicated by the matrix multiplication. 

Since log domain should be preferred to avoid numerical underflow, multiplications are translated into sums of logs. Furthermore, we use Stan's implementation of the linear sums on the log scale to prevent underflow and overflow in the exponentiation [@team2017stan, p. 141]. In consequence, `unalpha_tk` represents the forward quantity in log scale and needs to be exponentially normalized for interpretability.

```{stan stan_forward_norm, echo = TRUE, eval = FALSE, output.var = "TRASH"}
generated quantities {
  vector[K] alpha_tk[T];

  { // Forward algortihm
    for (t in 1:T)
      alpha_tk[t] = softmax(unalpha_tk[t]);
  } // Forward
}
```

The unnormalized forward probability is a sufficient statistics that will be used for estimation in the model and, as such, should be part of either the `model` or the `transformed parameters` blocks. We chose the latter to keep track of the estimates. We expand on estimation afterward.

<!-- \begin{algorithm}[H] -->
<!--   \DontPrintSemicolon -->
<!--   \SetKwInOut{Input}{input} -->
<!--   \SetKwInOut{Output}{output} -->
<!--   \SetKwProg{Fn}{def}{\string:}{} -->

<!--   \Input{Transition matrix $\mat{\Psi}$, local evidence vector $\mat{\psi}_t$ and initial state distribution $\mat{\pi}$.} -->
<!--   \Output{Belief state vector $\mat{\alpha}_{1:T}$ and log probability of the evidence $\log p(\mat{x}_{1:T} = \sum_{t} \log Z_t$).} -->
<!--   \BlankLine -->

<!--   \SetKwFunction{FUNCnormalize}{normalize} -->
<!--   \Fn(){ -->
<!--     \FUNCnormalize{$\mat{u}$} -->
<!--   }{ -->
<!--       $Z = \sum_j = u_j$\; -->
<!--       $v_j = u_j / Z$\; -->
<!--       \KwRet{$\mat{v}$, Z} -->
<!--   } -->

<!--   \BlankLine -->

<!--   $\alpha_1, Z_1 = \FuncSty{normalize}(\mat{\psi}_1 \odot \mat{\pi})$ \; -->
<!--   \For{t = 2 \KwTo T}{ -->
<!--     $\alpha_t, Z_t = \FuncSty{normalize}(\mat{\psi}_t \odot (\mat{\Psi}^T \mat{\alpha}_{t-1}))$ \; -->
<!--   } -->
<!--   \KwRet{$\mat{\alpha}$, $\sum_{t} \log Z_t$} -->
<!--   \caption{Forward Algorithm} -->
<!-- \end{algorithm} -->

### Smoothing
A smoother infers the belief state at a given state based on all the observations or evidence $p(z_t | \mat{x}_{1:T})$. Although noise and uncertainty are significantly reduced as a result of conditioning on past and future data, the smoothing process can only be run offline.

Inference can be done by means of the forward-backward algorithm, also know as the Baum-Welch algorithm [@baum1967inequality; @baum1970maximization]. Let $\gamma_t(j)$ be the desired smoothed posterior marginal,

\[
\gamma_t(j)
  \triangleq p(z_t = j | \mat{x}_{1:T}),
\]

$\alpha_t(j)$ be the filtered belief state at the step $t$ as defined previously, and $\beta_t(j)$ be the conditional likelihood of future evidence given that the hidden state at step $t$ is $j$,

\[
\beta_t(j) 
  \triangleq p(\mat{x}_{t+1:T} | z_t = j).
\]

Then, the chain of smoothed marginals can be segregated into the past and the future components by conditioning on the belief state $z_t$,

\[
\gamma_t(j)
  = p(z_t = j | \mat{x}_{1:T})
  \propto p(z_t = j,  \mat{x}_{t+1:T} | \mat{x}_{1:t})
  \propto p(z_t = j | \mat{x}_{1:t}) p(\mat{x}_{t+1:T} | z_t = j)
  \propto \alpha_t(j) \beta_t(j).
\]

The future component can be computed recursively from right to left:

\begin{align*}
\beta_{t-1}(i)
  &= p(\mat{x}_{t:T} | z_{t-1} = i) \\
  &= \sum_{j=1}^{K}{p(z_t =j, \mat{x}_{t}, \mat{x}_{t+1:T} | z_{t-1} = i)} \\
  &= \sum_{j=1}^{K}{p(\mat{x}_{t+1:T} | z_t = j)p(z_t = j, \mat{x}_{t} | z_{t-1} = i)} \\
  &= \sum_{j=1}^{K}{p(\mat{x}_{t+1:T} | z_t = j)p(\mat{x}_t | z_t = j)p(z_t = j | z_{t-1} = i)} \\
  &= \sum_{j=1}^{K}{\beta_t(j) \psi_t(j) \Psi(i, j)}
\end{align*}

Let $\mat{\beta}_t$ be a $K$-sized vector with the conditional likelihood of future evidence given the hidden state at step $t$. Then, the backward procedure can be expressed in matrix notation as

\[
\mat{\beta}_{t-1} \propto \mat{\Psi} (\mat{\psi}_t \odot \mat{\beta}_{t}).
\]

At the last step, the base case is given by
\[
\beta_{T}(i)
  = p(\mat{x}_{T+1:T} | z_{T} = i) = p(\varnothing | z_T = i) = 1.
\]

Intuitively, the forward-backward algorithm passes information from left to right and then from right to left, combining them at each node. A straightforward implementation of the algorithm runs in $O(K^2 T)$ time because of the $K \times K$ matrix multiplication at each step. There is a significant reduction if the transition matrix is sparse, for example a left-to-right transition matrix runs in $O(TK)$ time. Additional assumptions about the form of the transition matrix may ease complexity further, for example reducing the time to $O(TK\log K)$ if $\psi(i, j) \propto \exp(-\sigma^2 |\mat{z}_i - \mat{z}_j|)$.

```{stan stan_forwardbackward, echo = TRUE, eval = FALSE, output.var = "TRASH"}
functions {
  vector normalize(vector x) {
    return x / sum(x);
  }
}

generated quantities {
  vector[K] unbeta_tk[T];
  vector[K] ungamma_tk[T];

  vector[K] beta_tk[T];
  vector[K] gamma_tk[T];

  { // Forward algortihm
    for (t in 1:T)
      alpha_tk[t] = softmax(unalpha_tk[t]);
  } // Forward

  { // Backward algorithm log p(x_{t+1:T} | z_t = j)
    real accumulator[K];

    for (j in 1:K)
      unbeta_tk[T, j] = 1;

    for (tforward in 0:(T-2)) {
      int t;
      t = T - tforward;

      for (j in 1:K) { // j = previous (t-1)
        for (i in 1:K) { // i = next (t)
                         // Murphy (2012) Eq. 17.58
                         // backwards t    + transition prob + local evidence at t
          accumulator[i] = unbeta_tk[t, i] 
                           + log(A_ij[j, i]) 
                           + normal_lpdf(x_t[t] | mu_k[i], sigma_k[i]);
          }
        unbeta_tk[t-1, j] = log_sum_exp(accumulator);
      }
    }

    for (t in 1:T)
      beta_tk[t] = softmax(unbeta_tk[t]);
  } // Backward

  { // forward-backward algorithm log p(z_t = j | x_{1:T})
    for(t in 1:T) {
        ungamma_tk[t] = alpha_tk[t] .* beta_tk[t];
    }

    for(t in 1:T)
      gamma_tk[t] = normalize(ungamma_tk[t]);
  } // forward-backward
}
```

The reader should not be deceived by the similarity to the code shown in the filtering section. Note that the indices in the log transition matrix are inverted and the evidence is now computed for the next state. We need to invert the time index as backward ranges are available in Stan.

### MAP: Viterbi

It is also of interest to compute the most probable state sequence or path,

\[
\mat{z}^* = \argmax_{\mat{z}_{1:T}} p(\mat{z}_{1:T} | \mat{x}_{1:T}).
\]

The jointly most probable sequence of states can be inferred by means of maximum a posterior (MAP) estimation. It is not necessarily the same as the sequence of marginally most probable states given by the maximizer of the posterior marginals (MPM),

\[
\mat{\hat{z}} = (\argmax_{z_1} p(z_1 | \mat{x}_{1:T}), \dots, \argmax_{z_T} p(z_T | \mat{x}_{1:T})),
\]

which maximizes the expected number of correct individual states.

The MAP estimate is always globally consistent: while locally a state may be most probable at a given step, the Viterbi or max-sum algorithm decodes the most likely single plausible path [@viterbi1967error]. Furthermore, the MPM sequence may have zero joint probability if it includes two successive states that, while being individually the most probable, are connected in the transition matrix by a zero. On the other hand, MPM can be considered more robust since the state at each step is estimated by averaging over its neighbors rather than conditioning on a specific value of them.

The Viterbi algorithm is an adaptation of the forward-backward algorithm where the forward pass becomes a max-product and the backwards pass relies on a traceback procedure to recover the most probable path. In simple terms, once the most probable state $z_t$ is estimated, the procedure conditions the previous states on it. Let $\delta_t(j)$ be the probability of arriving to the state $j$ at step $t$ given the most probable path was taken,

\[
\delta_t(j)
  \triangleq \max_{z_1, \dots, z_{t-1}} p(\mat{z}_{1:t-1}, z_t = j | \mat{x}_{1:t}).
\]

The most probable path to state $j$ at step $t$ consists of the most probable path to some other state $i$ at point $t-1$, followed by a transition from $i$ to $j$,

\[
\delta_t(j)
  = \max_{i} \delta_{t-1}(i) \psi(i, j) \psi_t(j).
\]

Additionally, the most likely previous state on the most probable path to $j$ at step $t$ is given by
\[
a_t(j)
  = \argmax_{i} \delta_{t-1}(i) \psi(i, j) \psi_t(j).
\]

By initializing with $\delta_1 = \pi_j \phi_1(j)$ and terminating with the most probable final state $z_T^* = \argmax_{i} \delta_T(i)$, the most probable sequence of states is estimated using the traceback,

\[
z_t^* = a_{t+1}(z_{t+1}^*).
\]

It is advisable to work in the log domain to avoid numerical underflow,

\[
\delta_t(j)
  \triangleq \max_{\mat{z}_{1:t-1}} \log p(\mat{z}_{1:t-1}, z_t = j | \mat{x}_{1:t})
  = \max_{i} \log \delta_{t-1}(i) + \log \psi(i, j) + \log \psi_t(j).
\]

As with the backward-forward algorithm, the time complexity of Viterbi is $O(K^2T)$ and the space complexity is $O(KT)$. If the transition matrix has the form $\psi(i, j) \propto \exp(-\sigma^2 ||\mat{z}_i - \mat{z}_j||^2)$, implementation runs in $O(TK)$ time.

```{stan stan_viterbi, echo = TRUE, eval = FALSE, output.var = "TRASH"}
generated quantities {
  int<lower=1, upper=K> zstar_t[T];
  real logp_zstar_t;

  { // Viterbi algorithm
    int a_tk[T, K];       // backpointer to the most likely previous state 
                          // on the most probable path
    real delta_tk[T, K];  // max prob for the sequence up to t
                          // that ends with an emission from state k

    for (j in 1:K)
      delta_tk[1, K] = normal_lpdf(x_t[1] | mu_k[j], sigma_k[j]);

    for (t in 2:T) {
      for (j in 1:K) { // j = current (t)
        delta_tk[t, j] = negative_infinity();
        for (i in 1:K) { // i = previous (t-1)
          real logp;
          logp = delta_tk[t-1, i] 
                 + log(A_ij[i, j]) 
                 + normal_lpdf(x_t[t] | mu_k[j], sigma_k[j]);
          if (logp > delta_tk[t, j]) {
            a_tk[t, j] = i;
            delta_tk[t, j] = logp;
          }
        }
      }
    }

    logp_zstar_t = max(delta_tk[T]);

    for (j in 1:K)
      if (delta_tk[T, j] == logp_zstar_t)
        zstar_t[T] = j;

    for (t in 1:(T - 1)) {
      zstar_t[T - t] = a_tk[T - t + 1, zstar_t[T - t + 1]];
    }
  }
}
```

The variable `delta_tk` is a straightforward implementation of the corresponding equation. `a_tk` is the traceback needed to compute the most probable sequence of states after the most probably final state `zstar_t` is computed.

## Parameter estimation

The probability of a state at a certain time step $t$, given the history of evidence $\mat{x}_{1:t}$, is an average over all possible previous states (in other terms, previous state are marginalized out). The recurrent nature of the forward probability implies that the last iteration contains all the sufficient information to estimate the parameters.

```{stan stan_estimation, echo = TRUE, eval = FALSE, output.var = "TRASH"}
model {
  target += log_sum_exp(unalpha_tk[T]); // Note: update based only on last unalpha_tk
}
```

A sufficient statistic captures all the information that the sample contains about the parameter vector, achieving the maximal amount of data reduction possible without loss of information. More formally, a statistic $T(\mat{x}_t)$ is a sufficient statistic for the parameter vector $\mat{\theta}$ if the conditional distribution of the sample $\mat{x}_t$ given the value of $T(\mat{x}_t)$ does not depend on $\mat{\theta}$ [@casella2002statistical].

As illustrated in the Manual [@team2017stan, p. 353], sufficient statistics may be exploited to generate large efficiency gains: some models can be restated in an alternative, less complex way to produce a likelihood that is proportional to the expanded model.

```{r hmm_estimate, echo = TRUE, eval = TRUE, cache = TRUE}
hmm_init <- function(K, x_t) {
  clasif <- kmeans(x_t, K)
  init.mu <- by(x_t, clasif$cluster, mean)
  init.sigma <- by(x_t, clasif$cluster, sd)
  init.order <- order(init.mu)

  list(
    mu_k = init.mu[init.order],
    sigma_k = init.sigma[init.order]
  )
}

hmm_fit <- function(K, x_t) {
  rstan_options(auto_write = TRUE)
  options(mc.cores = parallel::detectCores())

  stan.model = 'stan/hmm_gaussian.stan'
  stan.data = list(
    T = length(x_t),
    K = K,
    x_t = x_t
  )

  stan(file = stan.model,
       data = stan.data, verbose = T,
       iter = 400, warmup = 200,
       thin = 1, chains = 1,
       cores = 1, seed = 900,
       init = function(){hmm_init(K, x_t)})
}
```

As we expect high multimodality in the posterior density, we use a clustering algorithm to feed the sampler with initialization values for the location and scale parameters. Although K-means is not truthful to the real model because it does not consider the time-dependent nature of the data, it provides an educated guess.

## A walk-through

We draw one sample of length $T = 500$ from a data generating process with $K = 3$ latent states. We fit the model using the Stan code and the initialization methodology introduced previously.

```{r hmm_walkthrough_estimate, include = TRUE, eval = FALSE}
set.seed(900)
K        <- 3
T_length <- 500
dataset  <- hmm_generate(K, T_length)
fit      <- hmm_fit(K, dataset$x_t)
```

```{r hmm_walkthrough_estimate_run, results = "hide", eval = TRUE, cache = TRUE}
set.seed(900)
K        <- 3
T_length <- 500
dataset  <- hmm_generate(K, T_length)
fit      <- hmm_fit(K, dataset$x_t)
```

The estimates are extremely efficient as expected when dealing with generated data. The Markov Chain are well behaved as diagnosed by the low Monte Carlo standard error, the high effective sample size and the near-one shrink factor of @gelman1992inference. Although not shown, further diagnostics confirm satisfactory mixing, convergence and the absence of divergences. Point estimates and credibility intervals are provided by rstan's `summary` function.

```{r hmm_walkthrough_summary, include = FALSE, echo = TRUE, eval = TRUE}
knitr::kable(cbind(
             unlist(list(dataset$theta$p_1k, 
                        t(dataset$theta$A_ij), 
                        dataset$theta$mu_k, 
                        dataset$theta$sigma_k)),
             summary(fit,
                  pars = c('p_1k', 'A_ij', 'mu_k', 'sigma_k'),
                  probs = c(0.10, 0.50, 0.90))$summary),
             col.names = c("True", "Mean", "MCSE", "SE", "$q_{10\\%}$", "$q_{50\\%}$", "$q_{90\\%}$", "ESS", "$\\hat{R}$"),
      digits = 2, align = "r", caption = "Estimated parameters and hidden quantities. *MCSE = Monte Carlo Standard Error, SE = Standard Error, ESS = Effective Sample Size*.")
```

We extract the samples for some quantities of interest, namely the filtered probabilities vector $\mat{\alpha}_t$, the smoothed probability vector $\mat{\gamma}_t$ and the most probable hidden path $\mat{z}^*$. As an informal assessment that our software recover the hidden states correctly, we observe that the filtered probability, the smoothed probability and the most likely path are all reasonable accurate to the true values.

```{r hmm_walkthrough_stateprobability, include = TRUE, echo = FALSE, eval = TRUE, fig.height = 9, out.width="\\textwidth"}
alpha_tk <- extract(fit, pars = 'alpha_tk')[[1]]
gamma_tk <- extract(fit, pars = 'gamma_tk')[[1]]
plot_stateprobability(alpha_tk, gamma_tk, 0.8, dataset$z_t)
```

We identify an insignificant quantity of misclassifications product of the stochastic nature of our software.

```{r hmm_walkthrough_alpha, include = FALSE, echo = TRUE, eval = TRUE}
alpha_tk_med  <- apply(alpha_tk, c(2, 3), function(x) { quantile(x, c(0.50)) })
alpha_tk_hard <- apply(alpha_tk_med, 1, which.max)

# table(true = dataset$z_t, estimated = alpha_tk_hard)
knitr::kable(
      cbind(
        c("$z_t = 1$", "$z_t = 2$", "$z_t = 3$"),
        table(true = dataset$z_t, estimated = alpha_tk_hard)
      ),
      col.names = c("", "$\\hat{z}_t = 1$", "$\\hat{z}_t = 2$", "$\\hat{z}_t = 2$"),
      row.names = FALSE,
      digits = 2, align = "r", caption = "Hard classification according to the filtered probability.")
```

As expected, the MAP estimate recovers the simulated hidden path with no label switching due because of the ordinal constraints.

```{r hmm_walkthrough_statepath, include = TRUE, echo = FALSE, eval = TRUE, fig.height = 6, out.width="\\textwidth"}
zstar_t <- extract(fit, pars = 'zstar_t')[[1]]
plot_statepath(zstar_t, dataset$z_t)
```

```{r hmm_walkthrough_path, include = TRUE, echo = FALSE, eval = TRUE}
# table(true = dataset$z_t, estimated = apply(zstar_t, 2, median))

knitr::kable(
      cbind(
        c("$z_t = 1$", "$z_t = 2$", "$z_t = 3$"),
        table(true = dataset$z_t, estimated = apply(zstar_t, 2, median))
      ),
      col.names = c("", "$\\hat{z}_t = 1$", "$\\hat{z}_t = 2$", "$\\hat{z}_t = 2$"),
      row.names = FALSE,
      digits = 2, align = "r", caption = "Hard classification according to the Viterbi Algorithm.")
```

Finally, we plot the observed series colored according to the jointly most likely state.

```{r hmm_walkthrough_outputvit, include = TRUE, echo = FALSE, eval = TRUE, fig.height = 6, out.width="\\textwidth"}
plot_outputvit(x = dataset$x,
               z = dataset$z_t,
               zstar = zstar_t,
               main = "Most probable path")
```

# The Input-Output Hidden Markov Model

The IOHMM is an architecture proposed by @bengio1995input to map input sequences, sometimes called the control signal, to output sequences. It is a probabilistic framework that can deal with general sequence processing tasks such as production, classification and prediction. The main difference with Hidden Markov Models (HMM), which are part of the unsupervised learning paradigm, is the capability to learn the output sequence itself instead of the distribution of the output sequence.

## Definitions

As with HMM, IOHMM involves two interconnected models,

\begin{align*}
z_{t} &= f(z_{t-1}, \mat{u}_{t}) \\
\mat{x}_{t} &= g(z_{t  }, \mat{u}_{t}).
\end{align*}

The first line corresponds to the state model, which consists of discrete-time, discrete-state hidden states $z_t \in \{1, \dots, K\}$ whose transition depends on the previous hidden state $z_{t-1}$ and the input vector $\mat{u}_{t} \in \RR^M$. Additionally, the observation model is governed by $g(z_{t}, \mat{u}_{t})$, where $\mat{x}_t \in \RR^R$ is the vector of observations, emissions or output. The corresponding joint distribution is

\[
p(\mat{z}_{1:T}, \mat{x}_{1:T} | \mat{u}_{t}).
\]

In the proposed parametrization with continuous inputs and outputs, the state model involves a multinomial regression whose parameters depend on the previous state taking the value $i$,

\[
p(z_t | \mat{x}_{t}, \mat{u}_{t}, z_{t-1} = i) = \text{softmax}^{-1}(\mat{u}_{t} \mat{w}_i),
\]

and the observation model is built upon a linear regression with Gaussian error and parameters depending on the current state taking the value $j$,

\[
p(\mat{x}_t | \mat{u}_{t}, z_{t} = j) = \mathcal{N}(\mat{u}_t \mat{b}_j, \mat{\Sigma}_j)
\]

IOHMM adapts the logic of HMM to allow for input and output vectors, retaining its fully probabilistic quality. Hidden states are assumed to follow a multinomial distribution that depends on the input sequence. The transition probabilities $\Psi_t(i, j) = p(z_t = j | z_{t-1} = i, \mat{u}_{t})$, which govern the state dynamics, are driven by the control signal as well.

As for the output sequence, the local evidence at time $t$ now becomes $\psi_t(j) = p(\mat{x}_t | z_t = j, \mat{\eta}_t)$, where $\mat{\eta}_t = \ev{\mat{x}_t | z_t, \mat{u}_t}$ can be interpreted as the expected location parameter for the probability distribution of the emission $\mat{x}_{t}$ conditional on the input vector $\mat{u}_t$ and the hidden state $z_t$.

The actual form of the emission density $p(\mat{x}_t, \mat{\eta}_t)$ can be discrete or continuous. In case of sequence classification or symbolic mutually exclusive emissions, it is possible to set up the multinomial distribution by running the softmax function over the estimated outputs of all possible states. In this case, we approximate continuous observations with the Gaussian density, the target is estimated as a linear combination of these outputs.

The adaptation of the data and parameters blocks is straightforward: we add the number of input variables `M`, the array of input vectors `u_t`, the regressors `b_km` and the residual standard deviation `s_k`.

```{stan iohmm_params, echo = TRUE, eval = FALSE, output.var = "TRASH"}
data {
  int<lower=1> T;                   // number of observations (length)
  int<lower=1> K;                   // number of hidden states
  int<lower=1> M;                   // size of the input vector

  real x_t[T];                      // output (scalar so far)
  vector[M] u_tm[T];                // input vectors
}

parameters {
  // Discrete state model
  simplex[K] p_1k;                  // initial state probabilities
  vector[M] w_km[K];                // state regressors

  // Continuous observation model
  vector[M] b_km[K];                // mean regressors
  real<lower=0.0001> s_k[K];        // residual standard deviations
}
```

## Inference

### Filtering

The filtered marginals are computed recursively by adjusting the forward algorithm to consider the input sequence,

\begin{align*}
\alpha_t(j)
  & \triangleq p(z_t = j | \mat{x}_{1:t}, \mat{u}_{1:t}) \\
  & = \sum_{i = 1}^{K}{p(z_t = j | z_{t-1} = i, \mat{x}_{t}, \mat{u}_{t}) p(z_{t-1} = i | \mat{x}_{1:t-1}, \mat{u}_{1:t-1})} \\
  & = \sum_{i = 1}^{K}{p(\mat{x}_{t} | z_t = j, \mat{u}_t) p(z_t = j | z_{t-1} = i, \mat{u}_{t}) p(z_{t-1} = i | \mat{x}_{1:t-1}, \mat{u}_{1:t-1})} \\
  & = \psi_t(j) \sum_{i = 1}^{K}{\Psi_t(i, j) \alpha_{t-1}(i)}.
\end{align*}

The implementation in Stan requires one modification: the time-dependent transition probability matrix is now computed as the linear combination of the input variables and the parameters of the multinomial regression that drives the latent process.

```{stan iohmm_forward, echo = TRUE, eval = FALSE, output.var = "TRASH"}
transformed parameters {
  vector[K] unalpha_tk[T];

  vector[K] unA_ij[T];
  vector[K] A_ij[T];

  vector[K] oblik_tk[T];

  { // Transition probability matrix p(z_t = j | z_{t-1} = i, u_t)
    unA_ij[1] = p_1k; // Filler
    A_ij[1] = p_1k; // Filler
    for (t in 2:T) {
      for (j in 1:K) { // j = current (t)
        unA_ij[t][j] = u_t[t]' * w_km[j];
      }
      A_ij[t] = softmax(unA_ij[t]);
    }
  }

  { // Evidence (observation likelihood)
    for(t in 1:T) {
      for(j in 1:K) {
        oblik_tk[t][j] = normal_lpdf(x_t[t] | mu_k[j], s_k[j]);
      }
    }
  }

  { // Forward algorithm log p(z_t = j | x_{1:t})
    real accumulator[K];

    for(j in 1:K)
      unalpha_tk[1][j] = log(p_1k[j]) + oblik_tk[1][j];

    for (t in 2:T) {
      for (j in 1:K) { // j = current (t)
        for (i in 1:K) { // i = previous (t-1)
                         // Murphy (2012) Eq. 17.48
                         // belief state + transition prob + local evidence at t
          accumulator[i] = unalpha_tk[t-1, i] 
                           + log(A_ij[t][i]) 
                           + oblik_tk[t][j];
        }
        unalpha_tk[t, j] = log_sum_exp(accumulator);
      }
    }
  } // Forward
}
```

### Smoothing

A smoother infers the belief state at a given step based on all the observations or evidence,

\begin{align*}
\gamma_t(j)
  & \triangleq p(z_t = j | \mat{x}_{1:T}, \mat{u}_{1:T}) \\
  & \propto \alpha_t(j) \beta_t(j),
\end{align*}

where

\begin{align*}
\beta_{t-1}(i)
  & \triangleq p(\mat{x}_{t:T} | z_{t-1} = i, \mat{u}_{t:T}).
\end{align*}

Similarly, inference about the smoothed posterior marginal requires the adaptation of the forward-backward algorithm to consider the input sequence in both components $\alpha_t(j)$ and $\beta_t(j)$. The latter now becomes

\begin{align*}
\beta_{t-1}(i)
  & \triangleq p(\mat{x}_{t:T} | z_{t-1} = i, \mat{u}_{t:T}) \\
  & = \sum_{j = 1}^{K}{\psi_t(j) \Psi_t(i, j) \beta_{t}(j)}.
\end{align*}

Once adjusted the transition probability matrix, the Stan code for the forward-backward algorithm need no further modification.

### MAP: Viterbi

The Stan code for the Viterbi encoding algorithm need no further modification.

## Parameter estimation

The parameters of the models are $\mat{\theta} = (\mat{\pi}_1, \mat{\theta}_h, \mat{\theta}_o)$, where $\mat{\pi}_1$ is the initial state distribution, $\mat{\theta}_h$ are the parameters of the hidden model and $\mat{\theta}_o$ are the parameters of the state-conditional density function $p(\mat{x}_t | z_t = j, \mat{u}_t)$. State transition is characterized by a multinomial regression with parameters $\mat{w}_k$ for $k \in \{1, \dots, K\}$, while emissions are modeled by a linear regression with Gaussian error and parameters $\mat{b}_k$ and $\mat{\Sigma}_k$ for $k \in \{1, \dots, K\}$.

Estimation can be run under both the maximum likelihood and Bayesian frameworks. Although it is a straightforward procedure when the data is fully observed, in practice the latent states $\mat{z}_{1:T}$ are hidden. The most common approach is the application of the EM algorithm to find either the maximum likelihood or the maximum a posteriori estimates. @bengio1995input proposes a straightforward modification of the EM algorithm. The application of sigmoidal functions, for example the logistic or softmax transforms for the hidden transition model, requires numeric optimization via gradient ascent or similar methods for the M step. In this work, we exploit Stan's capabilities to produce a sampler that explores the posterior density of the model parameters.

## A walk-though the IOHMM

### Numerical stability for the softmax function
A digression! The softmax function, or normalized exponential function, can suffer from over or underflow in the exponentials. A naive implementation may fail:

```{r softmax_naive, echo = TRUE}
x <- 10^(1:5)
exp(x) / sum(exp(x))
```

A well known, safer implementation exploits the fact that softmax is location invariant, ie $softmax(\mat{x}) = softmax(\mat{x} + c)$ for any constant $c$. Subtracting the maximum value produces a new vector with non-positive entries, ruling out overflows, and at least one zero element, guaranteeing at least one significant term in the denominator.

```{r softmax_stable, echo = TRUE}
logsumexp <- function(x) {
  y = max(x)
  y + log(sum(exp(x - y)))
}

softmax <- function(x) {
  exp(x - logsumexp(x))
}

softmax(x)
```

This is already taken care in Stan [@team2017stan, p. 474].

### Back to the walk-though 

We first adapt the R routine for our new generative model. The arguments are the sequence length $T$, the number of discrete hidden states $K$, the input matrix $\mat{u}$, the initial state distribution vector $\mat{\pi}_1$, a matrix with the parameters of the multinomial regression that rules the hidden states dynamics $\mat{w}$, the name of a function drawing samples from the observation distribution and its arguments.

The initial hidden state is drawn from a multinomial distribution with one trial and event probabilities given by the initial state probability vector $\mat{\pi}_1$. The transition probabilities for each of the following steps $t \in \{2, \dots, T\}$ are generated from a multinomial regression with vector parameters $\mat{w}_k$, one set per possible hidden state $k \in \{1, \dots, K\}$, and covariates $\mat{u}_t$. The hidden states are subsequently sampled based on these transition probabilities.

The observation at each step may generate from a Gaussian with parameters $\mu_k$ and $\sigma_k$, one set per possible hidden state.

```{r iohmm_walkthrough_generate, echo = TRUE, eval = TRUE}
iohmm_generate <- function(T) {
  # 1. Parameters
  K <- 3
  M <- 4
  u_tm <- matrix(rnorm(T * M), nrow = T, ncol = M, byrow = TRUE)
  w_km <- matrix(
    c(1.2, 0.5, 0.3, 0.1, 0.5, 1.2, 0.3, 0.1, 0.5, 0.1, 1.2, 0.1),
    nrow = K, ncol = M, byrow = TRUE)
  b_km <- matrix(
    c(5.0, 6.0, 7.0, 0.5, 1.0, 5.0, 0.1, -0.5, 0.1, -1.0, -5.0, 0.2),
    nrow = K, ncol = M, byrow = TRUE)
  sigma_k <- c(0.2, 1.0, 2.5)
  p_1k <- c(0.4, 0.2, 0.4)
  
  p.mat <- matrix(0, nrow = T, ncol = K)
  p.mat[1, ] <- p_1k

  # 2. Hidden path
  z_t <- vector("numeric", T)
  z_t[1] <- sample(x = 1:K, size = 1, replace = FALSE, prob = p_1k)
  for (t in 2:T) {
    p.mat[t, ] <- softmax(sapply(1:K, function(j) {u_tm[t, ] %*% w_km[j, ]}))
    z_t[t] <- sample(x = 1:K, size = 1, replace = FALSE, prob = p.mat[t, ])
  }

  # 3. Observations
  x_t <- vector("numeric", T)
  for (t in 1:T) {
    x_t[t] <- rnorm(1, u_tm[t, ] %*% b_km[z_t[t], ], sigma_k[z_t[t]])
  }

  list(
    u_tm = u_tm,
    z_t = z_t,
    x_t = x_t,
    theta = list(p_1k = p_1k, w_km = w_km,
                 b_km = b_km, sigma_k = sigma_k, p.mat = p.mat)
  )
}
```

We draw one sample of length $T=500$ from a data generating process with $K=3$ latent states and run an exploratory analysis of the observed quantities.

```{r iohmm_walkthrough_simulate, include = TRUE, echo = TRUE, eval = TRUE}
set.seed(900)
K <- 3
T_length <- 500
dataset  <- iohmm_generate(T_length)
```

```{r iohmm_walkthrough_inputoutput, include = TRUE, echo = FALSE, eval = TRUE, fig.height = 9, out.width="\\textwidth"}
plot_inputoutput(x = dataset$x_t, u = dataset$u_tm, z = dataset$z_t)
```

We observe how the chosen values for the parameters affect the generated data. For example, the relationship between the third input $\mat{u}_3$ and the output $\mat{x}_t$ is positive, indifferent and negative for the hidden states $K = 1, 2, 3$ respectively. The true slopes are `r dataset$theta$b_km[1, 3]`, `r dataset$theta$b_km[2, 3]` and `r dataset$theta$b_km[3, 3]`.

```{r iohmm_walkthrough_inputprob, include = TRUE, echo = FALSE, eval = TRUE, fig.height = 9, out.width="\\textwidth"}
plot_inputprob(u = dataset$u_tm, p.mat = dataset$theta$p.mat, z = dataset$z_t)
```

We then analyse the relationship between the input and the state probabilities, which are usually hidden in applications with real data. The pairs $\{ \mat{u}_1, p(z_t = 1) \}$, $\{ \mat{u}_2, p(z_t = 2) \}$ and $\{ \mat{u}_3, p(z_t = 3) \}$ show the strongest relationships because of values of true regression parameters: those inputs take the largest weight in each state, namely $w_{11} = `r dataset$theta$w_km[1, 1]`$, $w_{22} = `r dataset$theta$w_km[2, 2]`$ and $w_{33} = `r dataset$theta$w_km[3, 3]`$.

We run the software to draw samples from the posterior density of model parameters and other hidden quantities.

```{r iohmm_walkthrough_estimate, include = TRUE, eval = FALSE}
iohmm_fit <- function(K, u_tm, x_t) {
  rstan_options(auto_write = TRUE)
  options(mc.cores = parallel::detectCores())
  
  stan.model = 'stan/iohmm_reg.stan'
  stan.data = list(
    T = nrow(u_tm),
    K = K,
    M = ncol(u_tm),
    u_tm = as.array(u_tm),
    x_t = x_t
  )
  
  stan(file = stan.model,
       data = stan.data, verbose = T,
       iter = 400, warmup = 200,
       thin = 1, chains = 1,
       cores = 1, seed = 900)
}

fit <- iohmm_fit(K, dataset$u_tm, dataset$x_t)
```

```{r iohmm_walkthrough_estimate_run, results = "hide", eval = TRUE, cache = TRUE}
iohmm_fit <- function(K, u_tm, x_t) {
  rstan_options(auto_write = TRUE)
  options(mc.cores = parallel::detectCores())
  
  stan.model = 'stan/iohmm_reg.stan'
  stan.data = list(
    T = nrow(u_tm),
    K = K,
    M = ncol(u_tm),
    u_tm = as.array(u_tm),
    x_t = x_t
  )
  
  stan(file = stan.model,
       data = stan.data, verbose = T,
       iter = 400, warmup = 200,
       thin = 1, chains = 1,
       cores = 1, seed = 900)
}

fit <- iohmm_fit(K, dataset$u_tm, dataset$x_t)
```

We rely on several diagnostic statistics and plots provided by rstan [@sdt2017rstan] and shinystan [@sdt2017shinystan] to assess mixing, convergence and the absence of divergences. Label switching hinders the comparison between true and observed parameters.

```{r iohmm_walkthrough_summary, include = TRUE, echo = FALSE, eval = TRUE}
knitr::kable(cbind(
             unlist(list(dataset$theta$p_1k, 
                        t(dataset$theta$w_km), 
                        dataset$theta$b_km, 
                        dataset$theta$sigma_k)),
             summary(fit,
                  pars = c('p_1k', 'w_km', 'b_km', 'sigma_k'),
                  probs = c(0.10, 0.50, 0.90))$summary),
             col.names = c("True", "Mean", "MCSE", "SE", "$q_{10\\%}$", "$q_{50\\%}$", "$q_{90\\%}$", "ESS", "$\\hat{R}$"),
      digits = 2, align = "r", caption = "Estimated parameters and hidden quantities. *MCSE = Monte Carlo Standard Error, SE = Standard Error, ESS = Effective Sample Size*.")
```

While mixing and convergence is extremely efficient, as expected when dealing with generated data, we note that the regression parameters for the latent states are the worst performers. The smaller effective size translates into higher Monte Carlo standard error and broader credibility intervals. One possible reason is that softmax is invariant to change in location, thus the parameters of a multinomial regression do not have a natural center and become harder to estimate.

We assess that our software recover the hidden states correctly. Due to label switching, the states generated under the labels 1 through 3 were recovered in a different order. In consequence, we decide to relabel the observations based on the best fit. This would not pose an inconvenient with real data as the hidden states are never observed.

```{r iohmm_walkthrough_relabeling, include = TRUE, echo = FALSE, eval = TRUE}
# Relabeling (ugly hack edition) -----------------------------------------
alpha_tk <- extract(fit, pars = 'alpha_tk')[[1]]
dataset$zrelab <- rep(0, T_length)

hard <- sapply(1:T_length, function(t, med) {
  which.max(med[t, ])
}, med = apply(alpha_tk, c(2, 3),
                    function(x) {
                      quantile(x, c(0.50)) }))

tab <- table(hard = hard, original = dataset$z_t)

for (k in 1:K) {
  dataset$zrelab[which(dataset$z_t == k)] <- which.max(tab[, k])
}

# table(new = dataset$zrelab, original = dataset$z_t)

knitr::kable(
      cbind(
        c("$z^r_1$", "$z^r_2$", "$z^r_3$"),
        table(new = dataset$zrelab, original = dataset$z_t)
      ),
      col.names = c("", "$z_1$", "$z_2$", "$z_3$"),
      row.names = FALSE,
      digits = 2, align = "r", caption = "Simulated hidden states are relabeled to match the order of the recovered states.")
```

The filtered probability is overly accurate, as expected, making the additional information contained in the smoothed seem of little value.

```{r iohmm_walkthrough_stateprobability, include = TRUE, echo = FALSE, eval = TRUE, fig.height = 9, out.width="\\textwidth"}
gamma_tk <- extract(fit, pars = 'gamma_tk')[[1]]
plot_stateprobability(alpha_tk, gamma_tk, 0.8, dataset$zrelab)
```

The confusion matrix makes evident that, under ideal conditions, the sampler works as intended.

```{r iohmm_walkthrough_filtered, include = TRUE, echo = FALSE, eval = TRUE}
knitr::kable(
      cbind(
        c("$z^r_t = 1$", "$z^r_t = 2$", "$z^r_t = 3$"),
        table(
          estimated = apply(round(apply(alpha_tk, c(2, 3),
                                        function(x) {
                                          quantile(x, c(0.50)) })), 1, which.max),
          real = dataset$zrelab)
      ),
      col.names = c("", "$\\hat{z}_t = 1$", "$\\hat{z}_t = 2$", "$\\hat{z}_t = 2$"),
      row.names = FALSE,
      digits = 2, align = "r", caption = "Hard classification according to the filtered probability.")
```

Similarly, the Viterbi algorithm recovers the expected most probably hidden state.

```{r iohmm_walkthrough_statepath, include = TRUE, echo = FALSE, eval = TRUE, fig.height = 6, out.width="\\textwidth"}
zstar_t <- extract(fit, pars = 'zstar_t')[[1]]
plot_statepath(zstar_t, dataset$zrelab)
```

```{r iohmm_walkthrough_path, include = TRUE, echo = FALSE, eval = TRUE}
# table(true = dataset$z_t, estimated = apply(zstar_t, 2, median))

knitr::kable(
      cbind(
        c("$z^r_t = 1$", "$z^r_t = 2$", "$z^r_t = 3$"),
        table(true = dataset$z_t, estimated = apply(zstar_t, 2, median))
      ),
      col.names = c("", "$\\hat{z}_t = 1$", "$\\hat{z}_t = 2$", "$\\hat{z}_t = 2$"),
      row.names = FALSE,
      digits = 2, align = "r", caption = "Hard classification according to the Viterbi Algorithm.")
```

# Acknowledgements

The members of the Stan Development Team for being so passionate about Bayesian statistics and technically unbeatable. Special mentions to Aaron Goodman, Ben Bales and Bob Carpenter for their active participation in the discussions held in Stan forums for [HMM with constraints](http://discourse.mc-stan.org/t/hidden-markov-model-with-constraints/1625/4) and [HMMM](http://discourse.mc-stan.org/t/transversing-up-a-graph-hierarchical-hidden-markov-model/1304/11). Although not strictly related, the discussion remains very valuable for the current Case Study.

This Case Study builds on top of my GSoC Project: [Bayesian Hierarchical Hidden Markov Models applied to financial time series](https://github.com/luisdamiano/gsoc17-hhmm). I thank Brian Peterson for being a great project leader and Michael Weylandt for being awesomely Bayesian and contributing with great statistical insight.

---

# Original Computing Environment

```{r computing_environment, echo = FALSE}
writeLines(readLines(file.path(Sys.getenv("HOME"), ".R/Makevars")))
devtools::session_info("rstan")
```

---

# References

<div id="refs"></div>

---
